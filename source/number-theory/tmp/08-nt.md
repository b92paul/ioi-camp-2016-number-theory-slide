# 質數專題


##線性算法 linear sieve

希望每個數字都只被篩法篩到一次(原本篩法會被所有質因數遍歷)

這演算法設計上希望所有的合數$m$都只被最小的質因數篩到


##
因此我們改變篩法的方向，

對於每個數字$m$我們用那些小於它的那些質數$p_i$乘上$m$，
去更新$m \times p_i$，讓其被篩掉，

在$p_i$尚未整除$m$之前，$p_i$一定比$m$中最小的質因數還要小。

##線性算法 Code

~~~{.cpp}
int p[N], np=0;
int a[N];     
for (int m = 2; m < N; m++) {
  if (a[m] == 0) p[np++] = m;
  for (i = 0; i<np && m*p[i]<N; i++) {
    a[m*p[i]] = 1;
    if (m%p[i] == 0) break;
  }
}
~~~

##
- 只要一發現某個質數$p_i$整除$m$，表示該質數是$m$最小的質數，

- 為了讓之後的數字都只被自己最小的質數篩掉

	就該從迴圈中跳出繼續窮舉。


##費馬質數判定

- 根據費馬小定理我們知道$a^{p-1}\equiv 1 \mod{p}$，

- 對於一個未知的$n$，

	我們在區間$[1,n-1]$中選擇很多個$a$來進行檢驗，

	如果結果都是1那在費馬質數判定中我們會說他是質數。

##錯誤?!

費馬質數判定的缺點是

存在著叫做偽質數 (Carmichael Numbers)數字$n$，所有$[1,n-1]$中的$a$都會滿足費馬小定理的等式，
但是$n$卻不是質數。

##Miller–Rabin 質數判定法

- 要判定$N$是否為質數。
- 首先將$N-1$分解為$2^sd$。

- 在每次測試先隨機選一個介於$[1, N-1]$的整數$a$，對所有的$r \in [0, s-1]$，
	若$a^d \mod N \neq 1且a^{2^{r}d} \mod N \neq -1$，
	則$N$是合數。
	不然，$N$有$3/4$的「機率」為質數。

##Code

~~~{.cpp}
bool miller_rabin(LL n, LL a) {
	if (__gcd(a, n) == n) return PRIME;
	if (__gcd(a, n) != 1) return COMPOSITE;
	LL d = n-1, r = 0, res;
	while(d%2==0) { ++r; d/=2; }
	res = bigmod(a, d, n); //計算 a 的 d 次方除以 n 的餘數
	if (res == 1 || res == n-1) return PRIME;
	while(r--) {
		res = mul(res, res, n); //小心乘法溢位
		if (res == n-1) return PRIME;
	}
	return COMPOSITE;
}
~~~



##Code

~~~{.cpp}
bool isprime(LL n) {
	LL as[7]={2, 325, 9375, 28178, 450775, 9780504, 1795265022};
	for(int i=0;i<7;i++)
		if(miller_rabin(n, as[i]) == COMPOSITE)
			return COMPOSITE;
	return PRIME;
}
~~~

##
注意到上面程式碼當中的as[]陣列。

~~~{.cpp}
LL as[7]={2, 325, 9375, 28178, 450775, 9780504, 1795265022};
~~~

其實在 $2^{64}$ 以內，只要用這幾個 $a$ 檢查過之後，
就可以完全確定範圍內的數字是否為質數了！
順帶一提，檢查 int 範圍內的質數只需要以 2, 7, 61 這三個數字為基底檢查就可以了。

把這幾個數字藏進 codebook 裡是個不錯的選擇唷！



##Miller–Rabin

因為是一定「機率」是質數，所以要做夠多次就幾乎確定該數字是否為質數。

但是沒有費馬質數判定法的問題，次數夠多一定可以把不是合數的數字篩掉。



##有趣質數 3*1家族

> 31, 331, 3331, 33331, 333331, 3333331, 33333331都是質數。
>
> 但33333331就不是了。



##梅森質數

> 形式為$2^k -1$的質數

前四個是$k =2,3,5,7$，目前最大的有17,425,170位數。



## The End
